#include "BVulkan.h"
#include "scene.h"
#include "XVulkan.h"

XProgram* program = nullptr;
XBufferObject *vbo = nullptr;
XUniformBuffer* ubo = nullptr;

void Init() {
	xInitDefaultTexture();
	Vertex vertexes[3];
	vertexes[0].SetPosition(-0.5f, -0.5f, -2.0f);
	vertexes[0].SetTexcoord(0.0f, 0.0f);
	vertexes[0].SetNormal(1.0f, 0.0f, 1.0f, 1.0f);
	vertexes[1].SetPosition(0.5f, -0.5f, -2.0f);
	vertexes[1].SetTexcoord(1.0f, 0.0f);
	vertexes[1].SetNormal(1.0f, 1.0f, 0.0f, 1.0f);
	vertexes[2].SetPosition(0.0f, 0.5f, -2.0f);
	vertexes[2].SetTexcoord(0.5f, 1.0f);
	vertexes[2].SetNormal(0.0f, 1.0f, 1.0f, 1.0f);
	// 创建buffer
	vbo = new XBufferObject;
	// 填充buffer
	xglBufferData(vbo, sizeof(Vertex) * 3, vertexes);
	
	// 创建program
	program = new XProgram;
	GLuint vs, fs;
	int file_len = 0;
	unsigned char* file_content = LoadFileContent("Res/test.vsb", file_len);
	// 创建shader
	xCreateShader(vs, file_content, file_len);
	delete[] file_content;

	file_content = LoadFileContent("Res/test.fsb", file_len);
	// 创建fs shader
	xCreateShader(fs, file_content, file_len);
	delete[] file_content;
	// 绑定shader
	xAttachVertexShader(program, vs);
	xAttachFragmentShader(program, fs);
	// 链接shader
	xLinkProgram(program);

	ubo = new XUniformBuffer;
	ubo->mType = kXUniformBufferTypeMatrix;
	ubo->mMatrices.resize(8);
	glm::mat4 projection = glm::perspective(60.0f, float(GetViewportWidth()) / float(GetViewportHeight()), 0.1f, 100.0f);
	projection[1][1] *= -1.0f;
	memcpy(ubo->mMatrices[2].mData, glm::value_ptr(projection), sizeof(XMatrix4x4f));
	xGenBuffer(ubo->mBuffer, ubo->mMemory, sizeof(XMatrix4x4f) * 8,
		VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT, VK_MEMORY_PROPERTY_HOST_COHERENT_BIT |
		VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT);
	xSubmitUniformBuffer(ubo);
}

void Draw(float deltaTime) {
	static float r = 0.0f;
	static float accTime = 0.0f;
	// 是否需要改变texture
	static bool modifiedTexture = false;
	// 是否需要更新UBO
	static bool modifiedUBO = false;
	r += deltaTime;
	accTime += deltaTime;
	if (r >= 1.0f) {
		r = 0.0f;
	}
	if (accTime > 3.0f) {
		if (modifiedTexture == false) {
			modifiedTexture = true;
			int image_width, image_height, channel;
			// 加载图片
			unsigned char* pixel = LoadImageFromFile("Res/textures/test.bmp", image_width, image_height, channel, 4);
			// 更新texture
			xSubmitImage2D(xGetDefaultTexture(), image_width, image_height, pixel);
			// 释放pixel内存
			delete[] pixel;
		}
	}
	if (accTime > 2.0f) {
		if (modifiedUBO == false) {
			modifiedUBO = true;
			xRebindUniformBuffer(program, 1, ubo);
		}
	}
	float color[] = { r,r,r,1.0f };
	aClearColor(0.1f, 0.4f, 0.6f, 1.0f);
	VkCommandBuffer commandbuffer = aBeginRendering();
	glUseProgram(program);
	glBindVertexBuffer(vbo);
	// 更新veretxbuffer 中 2号vec的颜色
	xUniform4fv(program, 2, color);
	glDrawArrays(A_TRIANGLES, 0, 3);
	aEndRenderingCommand();
	// 交换前后缓冲区
	aSwapBuffers();
}

void OnViewportChanged(int width, int height) {
	aViewport(width, height);
}

void OnQuit() {
	if (program != nullptr) {
		delete program;
	}
	// 释放ubo的资源
	if (ubo != nullptr) {
		delete ubo;
	}

	if (vbo != nullptr) {
		glDeleteBufferObject(vbo);
	}
	xVulkanCleanUp();
}